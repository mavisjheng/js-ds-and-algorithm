// dynamic programming: the opposite of recursion, starts at the bottom, solves small problems and combines them to form an overall solution to the big problem
// usually using an array holds the results of the many subsolutions as the problem is broken down
// fibonacci sequence: generated by adding the previous two numbers in the sequence together
// compare elapsed time: recursion, dynamic programming and iterative

// 1.recursion, extremely inefficient, too many values are recomputed during the recursive calls
function recurFib(n) {
  if (n <= 1) {
    return n;
  }
  else {
    return recurFib(n-1) + recurFib(n-2);
  }
}

// 2.dynamic programming
// starts by solving the simplest subproblem, then using that solution to solve more complex subproblems until the entire problem is solved
function dynFib(n) {
  var Fibonacci = [0, 1];                              // store intermediate results
  if (n >= 2) {
    for (var i = 2; i <= n; i++) {
      Fibonacci[i] = Fibonacci[i-1] + Fibonacci[i-2];
    }
  }
  //console.log(Fibonacci);
  return Fibonacci[n];
}

// 3.iterative, not really necessary to use an array when computing a Fibonacci number
function iterFib(n) {
  if (n <= 1) {
    return n;
  }
  var nextLast = 0;
  var last = 1;
  var result;
  for (var i = 2; i <= n; i++) {
    result = last + nextLast;
    nextLast = last;
    last = result;
  }
  return result;
}

var start, stop;
start = new Date().getTime();
console.log(recurFib(30));
stop = new Date().getTime();
console.log("recursion Fibonacci - " + (stop-start) + " milliseconds");
console.log();

start = new Date().getTime();
console.log(dynFib(30));
stop = new Date().getTime();
console.log("dynamic programming Fibonacci - " + (stop-start) + " milliseconds");
console.log();

start = new Date().getTime();
console.log(iterFib(30));
stop = new Date().getTime();
console.log("iterative Fibonacci - " + (stop-start) + " milliseconds");
console.log();

